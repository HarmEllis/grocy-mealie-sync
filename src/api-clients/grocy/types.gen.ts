// This file is auto-generated by @hey-api/openapi-ts

export type Product = {
    id?: number;
    name?: string;
    description?: string;
    location_id?: number;
    qu_id_purchase?: number;
    qu_id_stock?: number;
    enable_tare_weight_handling?: number;
    not_check_stock_fulfillment_for_recipes?: number;
    product_group_id?: number;
    tare_weight?: number;
    min_stock_amount?: number;
    default_best_before_days?: number;
    default_best_before_days_after_open?: number;
    picture_file_name?: string;
    row_created_timestamp?: string;
    shopping_location_id?: number;
    treat_opened_as_out_of_stock?: number;
    auto_reprint_stock_label?: number;
    no_own_stock?: number;
    /**
     * Key/value pairs of userfields
     */
    userfields?: {
        [key: string]: unknown;
    };
    should_not_be_frozen?: number;
    default_consume_location_id?: number;
    move_on_open?: number;
};

export type ProductWithoutUserfields = {
    id?: number;
    name?: string;
    description?: string;
    location_id?: number;
    qu_id_purchase?: number;
    qu_id_stock?: number;
    enable_tare_weight_handling?: number;
    not_check_stock_fulfillment_for_recipes?: number;
    product_group_id?: number;
    tare_weight?: number;
    min_stock_amount?: number;
    default_best_before_days?: number;
    default_best_before_days_after_open?: number;
    picture_file_name?: string;
    row_created_timestamp?: string;
    shopping_location_id?: number;
    treat_opened_as_out_of_stock?: number;
    auto_reprint_stock_label?: number;
    no_own_stock?: number;
    should_not_be_frozen?: number;
    default_consume_location_id?: number;
    move_on_open?: number;
};

export type QuantityUnit = {
    id?: number;
    name?: string;
    name_plural?: string;
    description?: string;
    row_created_timestamp?: string;
    plural_forms?: string;
    /**
     * Key/value pairs of userfields
     */
    userfields?: {
        [key: string]: unknown;
    };
};

export type Location = {
    id?: number;
    name?: string;
    description?: string;
    row_created_timestamp?: string;
    /**
     * Key/value pairs of userfields
     */
    userfields?: {
        [key: string]: unknown;
    };
};

export type ShoppingLocation = {
    id?: number;
    name?: string;
    description?: string;
    row_created_timestamp?: string;
    /**
     * Key/value pairs of userfields
     */
    userfields?: {
        [key: string]: unknown;
    };
};

export type StockLocation = {
    id?: number;
    product_id?: number;
    amount?: number;
    location_id?: number;
    location_name?: string;
    location_is_freezer?: number;
};

export type StockEntry = {
    id?: number;
    product_id?: number;
    location_id?: number;
    shopping_location_id?: number;
    amount?: number;
    best_before_date?: string;
    purchased_date?: string;
    /**
     * A unique id which references this stock entry during its lifetime
     */
    stock_id?: string;
    price?: number;
    open?: number;
    opened_date?: string;
    note?: string;
    row_created_timestamp?: string;
};

export type RecipeFulfillmentResponse = {
    recipe_id?: number;
    need_fulfilled?: boolean;
    need_fulfilled_with_shopping_list?: boolean;
    missing_products_count?: number;
    costs?: number;
};

export type ProductDetailsResponse = {
    product?: Product;
    product_barcodes?: Array<ProductBarcode>;
    quantity_unit_stock?: QuantityUnit;
    default_quantity_unit_purchase?: QuantityUnit;
    default_quantity_unit_consume?: QuantityUnit;
    quantity_unit_price?: QuantityUnit;
    last_purchased?: string;
    last_used?: string;
    stock_amount?: number;
    stock_amount_opened?: number;
    next_due_date?: string;
    /**
     * The price of the last purchase of the corresponding product
     */
    last_price?: number;
    /**
     * The average price af all stock entries currently in stock of the corresponding product
     */
    avg_price?: number;
    /**
     * The current price of the corresponding product, based on the stock entry to use next (defined by the default consume rule "Opened first, then first due first, then first in first out") or on the last price if the product is currently not in stock
     */
    current_price?: number;
    /**
     * This field is deprecated and will be removed in a future version (currently returns the same as `current_price`)
     * @deprecated
     */
    oldest_price?: number;
    last_shopping_location_id?: number;
    location?: Location;
    average_shelf_life_days?: number;
    spoil_rate_percent?: number;
    /**
     * True when the product is a parent product of others
     */
    has_childs?: boolean;
    default_location?: Location;
    /**
     * The conversion factor of the corresponding QU conversion from the product's qu_id_purchase to qu_id_stock
     */
    qu_conversion_factor_purchase_to_stock?: number;
    /**
     * The conversion factor of the corresponding QU conversion from the product's qu_id_price to qu_id_stock
     */
    qu_conversion_factor_price_to_stock?: number;
};

export type ProductPriceHistory = {
    date?: string;
    price?: number;
    shopping_location?: ShoppingLocation;
};

export type ProductBarcode = {
    product_id?: number;
    barcode?: string;
    qu_id?: number;
    shopping_location_id?: number;
    amount?: number;
    last_price?: number;
    note?: string;
};

export type ExternalBarcodeLookupResponse = {
    name?: string;
    location_id?: number;
    qu_id_purchase?: number;
    qu_id_stock?: number;
    qu_factor_purchase_to_stock?: number;
    /**
     * Can contain multiple barcodes separated by comma
     */
    barcode?: string;
    /**
     * The id of the added product, only included when the producted was added to the database
     */
    id?: number;
};

export type ChoreDetailsResponse = {
    chore?: Chore;
    /**
     * When this chore was last tracked
     */
    last_tracked?: string;
    /**
     * How often this chore was tracked so far
     */
    track_count?: number;
    last_done_by?: UserDto;
    next_estimated_execution_time?: string;
    next_execution_assigned_user?: UserDto;
    /**
     * Contains the average past execution frequency in hours or `null`, when the chore was never executed before
     */
    average_execution_frequency_hours?: number;
};

export type BatteryDetailsResponse = {
    chore?: Battery;
    /**
     * When this battery was last charged
     */
    last_charged?: string;
    /**
     * How often this battery was charged so far
     */
    charge_cycles_count?: number;
    next_estimated_charge_time?: string;
};

export type Session = {
    id?: number;
    session_key?: string;
    expires?: string;
    last_used?: string;
    row_created_timestamp?: string;
};

export type User = {
    id?: number;
    username?: string;
    first_name?: string;
    last_name?: string;
    password?: string;
    picture_file_name?: string;
    row_created_timestamp?: string;
};

/**
 * A user object without the *password* and with an additional *display_name* property
 */
export type UserDto = {
    id?: number;
    username?: string;
    first_name?: string;
    last_name?: string;
    display_name?: string;
    picture_file_name?: string;
    row_created_timestamp?: string;
};

export type ApiKey = {
    id?: number;
    api_key?: string;
    expires?: string;
    last_used?: string;
    row_created_timestamp?: string;
};

export type ShoppingListItem = {
    id?: number;
    shopping_list_id?: number;
    product_id?: number;
    note?: string;
    /**
     * The manual entered amount
     */
    amount?: number;
    row_created_timestamp?: string;
    /**
     * Key/value pairs of userfields
     */
    userfields?: {
        [key: string]: unknown;
    };
};

export type Battery = {
    id?: number;
    name?: string;
    description?: string;
    used_in?: string;
    charge_interval_days?: number;
    row_created_timestamp?: string;
    /**
     * Key/value pairs of userfields
     */
    userfields?: {
        [key: string]: unknown;
    };
};

export type BatteryChargeCycleEntry = {
    id?: number;
    battery_id?: number;
    tracked_time?: string;
    row_created_timestamp?: string;
};

export type Chore = {
    id?: number;
    name?: string;
    description?: string;
    period_type?: 'manually' | 'hourly' | 'daily' | 'weekly' | 'monthly';
    period_config?: string;
    period_days?: number;
    track_date_only?: boolean;
    rollover?: boolean;
    assignment_type?: 'no-assignment' | 'who-least-did-first' | 'random' | 'in-alphabetical-order';
    assignment_config?: string;
    next_execution_assigned_to_user_id?: number;
    start_date?: string;
    rescheduled_date?: string;
    rescheduled_next_execution_assigned_to_user_id?: number;
    row_created_timestamp?: string;
    /**
     * Key/value pairs of userfields
     */
    userfields?: {
        [key: string]: unknown;
    };
};

export type ChoreLogEntry = {
    id?: number;
    chore_id?: number;
    tracked_time?: string;
    row_created_timestamp?: string;
};

export type StockLogEntry = {
    id?: number;
    product_id?: number;
    amount?: number;
    best_before_date?: string;
    purchased_date?: string;
    used_date?: string;
    spoiled?: boolean;
    stock_id?: string;
    transaction_id?: string;
    transaction_type?: StockTransactionType;
    note?: string;
    row_created_timestamp?: string;
};

export type StockJournal = {
    correlation_id?: string;
    undone?: number;
    undone_timestamp?: string;
    amount?: number;
    location_id?: number;
    location_name?: string;
    product_name?: string;
    qu_name?: string;
    qu_name_plural?: string;
    user_display_name?: string;
    spoiled?: boolean;
    transaction_type?: StockTransactionType;
    row_created_timestamp?: string;
};

export type StockJournalSummary = {
    amount?: number;
    user_id?: number;
    product_name?: string;
    product_id?: number;
    qu_name?: string;
    qu_name_plural?: string;
    user_display_name?: string;
    transaction_type?: StockTransactionType;
};

export type Error400 = {
    error_message?: string;
};

export type Error500 = {
    error_message?: string;
    error_details?: {
        stack_trace?: string;
        file?: string;
        line?: number;
    };
};

export type CurrentStockResponse = {
    product_id?: number;
    amount?: number;
    amount_aggregated?: number;
    amount_opened?: number;
    amount_opened_aggregated?: number;
    /**
     * The next due date for this product
     */
    best_before_date?: string;
    /**
     * Indicates wheter this product has sub-products or not / if the fields `amount_aggregated` and `amount_opened_aggregated` are filled
     */
    is_aggregated_amount?: boolean;
    product?: ProductWithoutUserfields;
};

export type CurrentChoreResponse = {
    chore_id?: number;
    chore_name?: string;
    last_tracked_time?: string;
    track_date_only?: boolean;
    /**
     * The next estimated execution time of this chore, 2999-12-31 23:59:59 when the given chore has a period_type of manually
     */
    next_estimated_execution_time?: string;
    next_execution_assigned_to_user_id?: number;
    is_rescheduled?: boolean;
    is_reassigned?: boolean;
    next_execution_assigned_user?: UserDto;
};

export type CurrentBatteryResponse = {
    battery_id?: number;
    last_tracked_time?: string;
    /**
     * The next estimated charge time of this battery, 2999-12-31 23:59:59 when the given battery has no charge_interval_days defined
     */
    next_estimated_charge_time?: string;
};

export type CurrentVolatilStockResponse = {
    due_products?: Array<CurrentStockResponse>;
    overdue_products?: Array<CurrentStockResponse>;
    expired_products?: Array<CurrentStockResponse>;
    missing_products?: Array<{
        id?: number;
        name?: string;
        amount_missing?: number;
        is_partly_in_stock?: number;
    }>;
};

export type Task = {
    id?: number;
    name?: string;
    description?: string;
    due_date?: string;
    done?: number;
    done_timestamp?: string;
    category_id?: number;
    assigned_to_user_id?: number;
    row_created_timestamp?: string;
    /**
     * Key/value pairs of userfields
     */
    userfields?: {
        [key: string]: unknown;
    };
};

export type TaskCategory = {
    id?: number;
    name?: string;
    description?: string;
    row_created_timestamp?: string;
};

export type CurrentTaskResponse = {
    id?: number;
    name?: string;
    description?: string;
    due_date?: string;
    done?: number;
    done_timestamp?: string;
    category_id?: number;
    assigned_to_user_id?: number;
    row_created_timestamp?: string;
    assigned_to_user?: UserDto;
    category?: TaskCategory;
};

export type DbChangedTimeResponse = {
    changed_time?: string;
};

export type TimeResponse = {
    timezone?: string;
    time_local?: string;
    time_local_sqlite3?: string;
    time_utc?: string;
    timestamp?: number;
    offset?: number;
};

export type UserSetting = {
    value?: string;
};

export type MissingLocalizationRequest = {
    text?: string;
};

export type ExposedEntity = 'products' | 'chores' | 'product_barcodes' | 'batteries' | 'locations' | 'quantity_units' | 'quantity_unit_conversions' | 'shopping_list' | 'shopping_lists' | 'shopping_locations' | 'recipes' | 'recipes_pos' | 'recipes_nestings' | 'tasks' | 'task_categories' | 'product_groups' | 'equipment' | 'api_keys' | 'userfields' | 'userentities' | 'userobjects' | 'meal_plan' | 'stock_log' | 'stock' | 'stock_current_locations' | 'chores_log' | 'meal_plan_sections' | 'products_last_purchased' | 'products_average_price' | 'quantity_unit_conversions_resolved' | 'recipes_pos_resolved' | 'battery_charge_cycles' | 'product_barcodes_view';

export type ExposedEntityNoListing = 'api_keys';

export type ExposedEntityNoEdit = 'stock_log' | 'api_keys' | 'stock' | 'stock_current_locations' | 'chores_log' | 'products_last_purchased' | 'products_average_price' | 'quantity_unit_conversions_resolved' | 'recipes_pos_resolved' | 'battery_charge_cycles' | 'product_barcodes_view';

export type ExposedEntityNoDelete = 'stock_log' | 'stock' | 'stock_current_locations' | 'chores_log' | 'products_last_purchased' | 'products_average_price' | 'quantity_unit_conversions_resolved' | 'recipes_pos_resolved' | 'battery_charge_cycles' | 'product_barcodes_view';

export type ExposedEntityEditRequiresAdmin = unknown;

export type StockTransactionType = 'purchase' | 'consume' | 'inventory-correction' | 'product-opened';

export type FileGroups = 'equipmentmanuals' | 'recipepictures' | 'productpictures' | 'userfiles' | 'userpictures';

export type StringEnumTemplate = '';

export type ExposedEntityIncludingUserEntities = '' | 'api_keys' | 'batteries' | 'battery_charge_cycles' | 'chores' | 'chores_log' | 'equipment' | 'locations' | 'meal_plan' | 'meal_plan_sections' | 'product_barcodes' | 'product_barcodes_view' | 'product_groups' | 'products' | 'products_average_price' | 'products_last_purchased' | 'quantity_unit_conversions' | 'quantity_unit_conversions_resolved' | 'quantity_units' | 'recipes' | 'recipes_nestings' | 'recipes_pos' | 'recipes_pos_resolved' | 'shopping_list' | 'shopping_lists' | 'shopping_locations' | 'stock' | 'stock_current_locations' | 'stock_log' | 'task_categories' | 'tasks' | 'userentities' | 'userfields' | 'userobjects' | 'users';

export type ExposedEntityNotIncludingNotEditable = '' | 'batteries' | 'chores' | 'equipment' | 'locations' | 'meal_plan' | 'meal_plan_sections' | 'product_barcodes' | 'product_groups' | 'products' | 'quantity_unit_conversions' | 'quantity_units' | 'recipes' | 'recipes_nestings' | 'recipes_pos' | 'shopping_list' | 'shopping_lists' | 'shopping_locations' | 'task_categories' | 'tasks' | 'userentities' | 'userfields' | 'userobjects';

export type ExposedEntityIncludingUserEntitiesNotIncludingNotEditable = '' | 'batteries' | 'chores' | 'equipment' | 'locations' | 'meal_plan' | 'meal_plan_sections' | 'product_barcodes' | 'product_groups' | 'products' | 'quantity_unit_conversions' | 'quantity_units' | 'recipes' | 'recipes_nestings' | 'recipes_pos' | 'shopping_list' | 'shopping_lists' | 'shopping_locations' | 'stock' | 'task_categories' | 'tasks' | 'userentities' | 'userfields' | 'userobjects' | 'users';

export type ExposedEntityNotIncludingNotDeletable = '' | 'api_keys' | 'batteries' | 'chores' | 'equipment' | 'locations' | 'meal_plan' | 'meal_plan_sections' | 'product_barcodes' | 'product_groups' | 'products' | 'quantity_unit_conversions' | 'quantity_units' | 'recipes' | 'recipes_nestings' | 'recipes_pos' | 'shopping_list' | 'shopping_lists' | 'shopping_locations' | 'task_categories' | 'tasks' | 'userentities' | 'userfields' | 'userobjects';

export type ExposedEntityNotIncludingNotListable = '' | 'batteries' | 'battery_charge_cycles' | 'chores' | 'chores_log' | 'equipment' | 'locations' | 'meal_plan' | 'meal_plan_sections' | 'product_barcodes' | 'product_barcodes_view' | 'product_groups' | 'products' | 'products_average_price' | 'products_last_purchased' | 'quantity_unit_conversions' | 'quantity_unit_conversions_resolved' | 'quantity_units' | 'recipes' | 'recipes_nestings' | 'recipes_pos' | 'recipes_pos_resolved' | 'shopping_list' | 'shopping_lists' | 'shopping_locations' | 'stock' | 'stock_current_locations' | 'stock_log' | 'task_categories' | 'tasks' | 'userentities' | 'userfields' | 'userobjects';

/**
 * A valid field name by which the response should be ordered, use the separator `:` to specify the sort order (`asc` or `desc`, defaults to `asc` when omitted)
 */
export type Order = string;

/**
 * The maximum number of objects to return
 */
export type Limit = number;

/**
 * The number of objects to skip
 */
export type Offset = number;

/**
 * Offset of timestamp in seconds. Can be positive or negative.
 */
export type Offsettime = number;

/**
 * An array of filter conditions, each of them is a string in the form of `<field><condition><value>` where<br>`<field>` is a valid field name<br>`<condition>` is a comparison operator, one of<br>&nbsp;&nbsp;`=` equal<br>&nbsp;&nbsp;`!=` not equal<br>&nbsp;&nbsp;`~` LIKE<br>&nbsp;&nbsp;`!~` not LIKE<br>&nbsp;&nbsp;`<` less<br>&nbsp;&nbsp;`>` greater<br>&nbsp;&nbsp;`<=` less or equal<br>&nbsp;&nbsp;`>=` greater or equal<br>&nbsp;&nbsp;`§` regular expression<br>`<value>` is the value to search for
 */
export type Query = Array<string>;

export type GetSystemInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/system/info';
};

export type GetSystemInfoResponses = {
    /**
     * An DbChangedTimeResponse object
     */
    200: {
        grocy_version?: {
            Version?: string;
            ReleaseDate?: string;
        };
        php_version?: string;
        sqlite_version?: string;
    };
};

export type GetSystemInfoResponse = GetSystemInfoResponses[keyof GetSystemInfoResponses];

export type GetSystemDbChangedTimeData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/system/db-changed-time';
};

export type GetSystemDbChangedTimeResponses = {
    /**
     * An DbChangedTimeResponse object
     */
    200: DbChangedTimeResponse;
};

export type GetSystemDbChangedTimeResponse = GetSystemDbChangedTimeResponses[keyof GetSystemDbChangedTimeResponses];

export type GetSystemConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/system/config';
};

export type GetSystemConfigErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type GetSystemConfigError = GetSystemConfigErrors[keyof GetSystemConfigErrors];

export type GetSystemConfigResponses = {
    /**
     * Key/value pairs of config settings
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetSystemConfigResponse = GetSystemConfigResponses[keyof GetSystemConfigResponses];

export type GetSystemTimeData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Offset of timestamp in seconds. Can be positive or negative.
         */
        offset?: number;
    };
    url: '/system/time';
};

export type GetSystemTimeErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type GetSystemTimeError = GetSystemTimeErrors[keyof GetSystemTimeErrors];

export type GetSystemTimeResponses = {
    /**
     * A TimeResponse object
     */
    200: TimeResponse;
};

export type GetSystemTimeResponse = GetSystemTimeResponses[keyof GetSystemTimeResponses];

export type GetSystemLocalizationStringsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/system/localization-strings';
};

export type GetSystemLocalizationStringsResponses = {
    /**
     * A gettext JSON representation
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetSystemLocalizationStringsResponse = GetSystemLocalizationStringsResponses[keyof GetSystemLocalizationStringsResponses];

export type PostSystemLogMissingLocalizationData = {
    /**
     * A valid MissingLocalizationRequest object
     */
    body: MissingLocalizationRequest;
    path?: never;
    query?: never;
    url: '/system/log-missing-localization';
};

export type PostSystemLogMissingLocalizationErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type PostSystemLogMissingLocalizationError = PostSystemLogMissingLocalizationErrors[keyof PostSystemLogMissingLocalizationErrors];

export type PostSystemLogMissingLocalizationResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostSystemLogMissingLocalizationResponse = PostSystemLogMissingLocalizationResponses[keyof PostSystemLogMissingLocalizationResponses];

export type GetObjectsByEntityData = {
    body?: never;
    path: {
        /**
         * A valid entity name
         */
        entity: ExposedEntityNotIncludingNotListable;
    };
    query?: {
        /**
         * An array of filter conditions, each of them is a string in the form of `<field><condition><value>` where<br>`<field>` is a valid field name<br>`<condition>` is a comparison operator, one of<br>&nbsp;&nbsp;`=` equal<br>&nbsp;&nbsp;`!=` not equal<br>&nbsp;&nbsp;`~` LIKE<br>&nbsp;&nbsp;`!~` not LIKE<br>&nbsp;&nbsp;`<` less<br>&nbsp;&nbsp;`>` greater<br>&nbsp;&nbsp;`<=` less or equal<br>&nbsp;&nbsp;`>=` greater or equal<br>&nbsp;&nbsp;`§` regular expression<br>`<value>` is the value to search for
         */
        'query[]'?: Array<string>;
        /**
         * A valid field name by which the response should be ordered, use the separator `:` to specify the sort order (`asc` or `desc`, defaults to `asc` when omitted)
         */
        order?: string;
        /**
         * The maximum number of objects to return
         */
        limit?: number;
        /**
         * The number of objects to skip
         */
        offset?: number;
    };
    url: '/objects/{entity}';
};

export type GetObjectsByEntityErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
    /**
     * The operation was not successful (possible errors are invalid field names or conditions in filter parameters provided)
     */
    500: Error500;
};

export type GetObjectsByEntityError = GetObjectsByEntityErrors[keyof GetObjectsByEntityErrors];

export type GetObjectsByEntityResponses = {
    /**
     * An entity object
     */
    200: Array<Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode>;
};

export type GetObjectsByEntityResponse = GetObjectsByEntityResponses[keyof GetObjectsByEntityResponses];

export type PostObjectsByEntityData = {
    /**
     * A valid entity object of the entity specified in parameter *entity*
     */
    body: Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode;
    path: {
        /**
         * A valid entity name
         */
        entity: ExposedEntityNotIncludingNotEditable;
    };
    query?: never;
    url: '/objects/{entity}';
};

export type PostObjectsByEntityErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type PostObjectsByEntityError = PostObjectsByEntityErrors[keyof PostObjectsByEntityErrors];

export type PostObjectsByEntityResponses = {
    /**
     * The operation was successful
     */
    200: {
        /**
         * The id of the created object
         */
        created_object_id?: number;
    };
};

export type PostObjectsByEntityResponse = PostObjectsByEntityResponses[keyof PostObjectsByEntityResponses];

export type DeleteObjectsByEntityByObjectIdData = {
    body?: never;
    path: {
        /**
         * A valid entity name
         */
        entity: ExposedEntityNotIncludingNotDeletable;
        /**
         * A valid object id of the given entity
         */
        objectId: number;
    };
    query?: never;
    url: '/objects/{entity}/{objectId}';
};

export type DeleteObjectsByEntityByObjectIdErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type DeleteObjectsByEntityByObjectIdError = DeleteObjectsByEntityByObjectIdErrors[keyof DeleteObjectsByEntityByObjectIdErrors];

export type DeleteObjectsByEntityByObjectIdResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type DeleteObjectsByEntityByObjectIdResponse = DeleteObjectsByEntityByObjectIdResponses[keyof DeleteObjectsByEntityByObjectIdResponses];

export type GetObjectsByEntityByObjectIdData = {
    body?: never;
    path: {
        /**
         * A valid entity name
         */
        entity: ExposedEntityNotIncludingNotListable;
        /**
         * A valid object id of the given entity
         */
        objectId: number;
    };
    query?: never;
    url: '/objects/{entity}/{objectId}';
};

export type GetObjectsByEntityByObjectIdErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
    /**
     * Object not found
     */
    404: Error400;
};

export type GetObjectsByEntityByObjectIdError = GetObjectsByEntityByObjectIdErrors[keyof GetObjectsByEntityByObjectIdErrors];

export type GetObjectsByEntityByObjectIdResponses = {
    /**
     * An entity object
     */
    200: Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode;
};

export type GetObjectsByEntityByObjectIdResponse = GetObjectsByEntityByObjectIdResponses[keyof GetObjectsByEntityByObjectIdResponses];

export type PutObjectsByEntityByObjectIdData = {
    /**
     * A valid entity object of the entity specified in parameter *entity*
     */
    body: Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode;
    path: {
        /**
         * A valid entity name
         */
        entity: ExposedEntityNotIncludingNotEditable;
        /**
         * A valid object id of the given entity
         */
        objectId: number;
    };
    query?: never;
    url: '/objects/{entity}/{objectId}';
};

export type PutObjectsByEntityByObjectIdErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type PutObjectsByEntityByObjectIdError = PutObjectsByEntityByObjectIdErrors[keyof PutObjectsByEntityByObjectIdErrors];

export type PutObjectsByEntityByObjectIdResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PutObjectsByEntityByObjectIdResponse = PutObjectsByEntityByObjectIdResponses[keyof PutObjectsByEntityByObjectIdResponses];

export type GetUserfieldsByEntityByObjectIdData = {
    body?: never;
    path: {
        /**
         * A valid entity name
         */
        entity: ExposedEntityIncludingUserEntities;
        /**
         * A valid object id of the given entity
         */
        objectId: string;
    };
    query?: never;
    url: '/userfields/{entity}/{objectId}';
};

export type GetUserfieldsByEntityByObjectIdErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type GetUserfieldsByEntityByObjectIdError = GetUserfieldsByEntityByObjectIdErrors[keyof GetUserfieldsByEntityByObjectIdErrors];

export type GetUserfieldsByEntityByObjectIdResponses = {
    /**
     * Key/value pairs of userfields
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetUserfieldsByEntityByObjectIdResponse = GetUserfieldsByEntityByObjectIdResponses[keyof GetUserfieldsByEntityByObjectIdResponses];

export type PutUserfieldsByEntityByObjectIdData = {
    /**
     * Key/value pairs of userfields
     */
    body: unknown;
    path: {
        /**
         * A valid entity name
         */
        entity: ExposedEntityIncludingUserEntitiesNotIncludingNotEditable;
        /**
         * A valid object id of the given entity
         */
        objectId: string;
    };
    query?: never;
    url: '/userfields/{entity}/{objectId}';
};

export type PutUserfieldsByEntityByObjectIdErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type PutUserfieldsByEntityByObjectIdError = PutUserfieldsByEntityByObjectIdErrors[keyof PutUserfieldsByEntityByObjectIdErrors];

export type PutUserfieldsByEntityByObjectIdResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PutUserfieldsByEntityByObjectIdResponse = PutUserfieldsByEntityByObjectIdResponses[keyof PutUserfieldsByEntityByObjectIdResponses];

export type DeleteFilesByGroupByFileNameData = {
    body?: never;
    path: {
        /**
         * The file group
         */
        group: FileGroups;
        /**
         * The file name (including extension)<br>**BASE64 encoded**
         */
        fileName: string;
    };
    query?: never;
    url: '/files/{group}/{fileName}';
};

export type DeleteFilesByGroupByFileNameErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type DeleteFilesByGroupByFileNameError = DeleteFilesByGroupByFileNameErrors[keyof DeleteFilesByGroupByFileNameErrors];

export type DeleteFilesByGroupByFileNameResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type DeleteFilesByGroupByFileNameResponse = DeleteFilesByGroupByFileNameResponses[keyof DeleteFilesByGroupByFileNameResponses];

export type GetFilesByGroupByFileNameData = {
    body?: never;
    path: {
        /**
         * The file group
         */
        group: FileGroups;
        /**
         * The file name (including extension)<br>**BASE64 encoded**
         */
        fileName: string;
    };
    query?: {
        /**
         * Force the file to be served as the given type
         */
        force_serve_as?: 'picture';
        /**
         * Only when using `force_serve_as` = `picture`: Downscale the picture to the given height while maintaining the aspect ratio
         */
        best_fit_height?: number;
        /**
         * Only when using `force_serve_as` = `picture`: Downscale the picture to the given width while maintaining the aspect ratio
         */
        best_fit_width?: number;
    };
    url: '/files/{group}/{fileName}';
};

export type GetFilesByGroupByFileNameErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type GetFilesByGroupByFileNameError = GetFilesByGroupByFileNameErrors[keyof GetFilesByGroupByFileNameErrors];

export type GetFilesByGroupByFileNameResponses = {
    /**
     * The binary file contents (Content-Type header is automatically set based on the file type)
     */
    200: Blob | File;
};

export type GetFilesByGroupByFileNameResponse = GetFilesByGroupByFileNameResponses[keyof GetFilesByGroupByFileNameResponses];

export type PutFilesByGroupByFileNameData = {
    body?: Blob | File;
    path: {
        /**
         * The file group
         */
        group: FileGroups;
        /**
         * The file name (including extension)<br>**BASE64 encoded**
         */
        fileName: string;
    };
    query?: never;
    url: '/files/{group}/{fileName}';
};

export type PutFilesByGroupByFileNameErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type PutFilesByGroupByFileNameError = PutFilesByGroupByFileNameErrors[keyof PutFilesByGroupByFileNameErrors];

export type PutFilesByGroupByFileNameResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PutFilesByGroupByFileNameResponse = PutFilesByGroupByFileNameResponses[keyof PutFilesByGroupByFileNameResponses];

export type GetUsersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * An array of filter conditions, each of them is a string in the form of `<field><condition><value>` where<br>`<field>` is a valid field name<br>`<condition>` is a comparison operator, one of<br>&nbsp;&nbsp;`=` equal<br>&nbsp;&nbsp;`!=` not equal<br>&nbsp;&nbsp;`~` LIKE<br>&nbsp;&nbsp;`!~` not LIKE<br>&nbsp;&nbsp;`<` less<br>&nbsp;&nbsp;`>` greater<br>&nbsp;&nbsp;`<=` less or equal<br>&nbsp;&nbsp;`>=` greater or equal<br>&nbsp;&nbsp;`§` regular expression<br>`<value>` is the value to search for
         */
        'query[]'?: Array<string>;
        /**
         * A valid field name by which the response should be ordered, use the separator `:` to specify the sort order (`asc` or `desc`, defaults to `asc` when omitted)
         */
        order?: string;
        /**
         * The maximum number of objects to return
         */
        limit?: number;
        /**
         * The number of objects to skip
         */
        offset?: number;
    };
    url: '/users';
};

export type GetUsersErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
    /**
     * The operation was not successful (possible errors are invalid field names or conditions in filter parameters provided)
     */
    500: Error500;
};

export type GetUsersError = GetUsersErrors[keyof GetUsersErrors];

export type GetUsersResponses = {
    /**
     * A list of user objects
     */
    200: Array<UserDto>;
};

export type GetUsersResponse = GetUsersResponses[keyof GetUsersResponses];

export type PostUsersData = {
    /**
     * A valid user object
     */
    body: User;
    path?: never;
    query?: never;
    url: '/users';
};

export type PostUsersErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type PostUsersError = PostUsersErrors[keyof PostUsersErrors];

export type PostUsersResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostUsersResponse = PostUsersResponses[keyof PostUsersResponses];

export type DeleteUsersByUserIdData = {
    body?: never;
    path: {
        /**
         * A valid user id
         */
        userId: number;
    };
    query?: never;
    url: '/users/{userId}';
};

export type DeleteUsersByUserIdErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type DeleteUsersByUserIdError = DeleteUsersByUserIdErrors[keyof DeleteUsersByUserIdErrors];

export type DeleteUsersByUserIdResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type DeleteUsersByUserIdResponse = DeleteUsersByUserIdResponses[keyof DeleteUsersByUserIdResponses];

export type PutUsersByUserIdData = {
    /**
     * A valid user object
     */
    body: User;
    path: {
        /**
         * A valid user id
         */
        userId: number;
    };
    query?: never;
    url: '/users/{userId}';
};

export type PutUsersByUserIdErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type PutUsersByUserIdError = PutUsersByUserIdErrors[keyof PutUsersByUserIdErrors];

export type PutUsersByUserIdResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PutUsersByUserIdResponse = PutUsersByUserIdResponses[keyof PutUsersByUserIdResponses];

export type GetUsersByUserIdPermissionsData = {
    body?: never;
    path: {
        /**
         * A valid user id
         */
        userId: number;
    };
    query?: never;
    url: '/users/{userId}/permissions';
};

export type GetUsersByUserIdPermissionsErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type GetUsersByUserIdPermissionsError = GetUsersByUserIdPermissionsErrors[keyof GetUsersByUserIdPermissionsErrors];

export type GetUsersByUserIdPermissionsResponses = {
    /**
     * A list of user permission objects
     */
    200: Array<{
        permission_id?: number;
        user_id?: number;
    }>;
};

export type GetUsersByUserIdPermissionsResponse = GetUsersByUserIdPermissionsResponses[keyof GetUsersByUserIdPermissionsResponses];

export type PostUsersByUserIdPermissionsData = {
    body: {
        /**
         * A permission ids
         */
        permissions_id?: number;
    };
    path: {
        /**
         * A valid user id
         */
        userId: number;
    };
    query?: never;
    url: '/users/{userId}/permissions';
};

export type PostUsersByUserIdPermissionsErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type PostUsersByUserIdPermissionsError = PostUsersByUserIdPermissionsErrors[keyof PostUsersByUserIdPermissionsErrors];

export type PostUsersByUserIdPermissionsResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostUsersByUserIdPermissionsResponse = PostUsersByUserIdPermissionsResponses[keyof PostUsersByUserIdPermissionsResponses];

export type PutUsersByUserIdPermissionsData = {
    body: {
        /**
         * A list of permission ids
         */
        permissions?: Array<number>;
    };
    path: {
        /**
         * A valid user id
         */
        userId: number;
    };
    query?: never;
    url: '/users/{userId}/permissions';
};

export type PutUsersByUserIdPermissionsErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type PutUsersByUserIdPermissionsError = PutUsersByUserIdPermissionsErrors[keyof PutUsersByUserIdPermissionsErrors];

export type PutUsersByUserIdPermissionsResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PutUsersByUserIdPermissionsResponse = PutUsersByUserIdPermissionsResponses[keyof PutUsersByUserIdPermissionsResponses];

export type GetUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user';
};

export type GetUserErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type GetUserError = GetUserErrors[keyof GetUserErrors];

export type GetUserResponses = {
    /**
     * A user object
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetUserResponse = GetUserResponses[keyof GetUserResponses];

export type GetUserSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/settings';
};

export type GetUserSettingsErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type GetUserSettingsError = GetUserSettingsErrors[keyof GetUserSettingsErrors];

export type GetUserSettingsResponses = {
    /**
     * Key/value pairs of user settings
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetUserSettingsResponse = GetUserSettingsResponses[keyof GetUserSettingsResponses];

export type DeleteUserSettingsBySettingKeyData = {
    body?: never;
    path: {
        /**
         * The key of the user setting
         */
        settingKey: string;
    };
    query?: never;
    url: '/user/settings/{settingKey}';
};

export type DeleteUserSettingsBySettingKeyErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type DeleteUserSettingsBySettingKeyError = DeleteUserSettingsBySettingKeyErrors[keyof DeleteUserSettingsBySettingKeyErrors];

export type DeleteUserSettingsBySettingKeyResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type DeleteUserSettingsBySettingKeyResponse = DeleteUserSettingsBySettingKeyResponses[keyof DeleteUserSettingsBySettingKeyResponses];

export type GetUserSettingsBySettingKeyData = {
    body?: never;
    path: {
        /**
         * The key of the user setting
         */
        settingKey: string;
    };
    query?: never;
    url: '/user/settings/{settingKey}';
};

export type GetUserSettingsBySettingKeyErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type GetUserSettingsBySettingKeyError = GetUserSettingsBySettingKeyErrors[keyof GetUserSettingsBySettingKeyErrors];

export type GetUserSettingsBySettingKeyResponses = {
    /**
     * A UserSetting object
     */
    200: UserSetting;
};

export type GetUserSettingsBySettingKeyResponse = GetUserSettingsBySettingKeyResponses[keyof GetUserSettingsBySettingKeyResponses];

export type PutUserSettingsBySettingKeyData = {
    /**
     * A valid UserSetting object
     */
    body: UserSetting;
    path: {
        /**
         * The key of the user setting
         */
        settingKey: string;
    };
    query?: never;
    url: '/user/settings/{settingKey}';
};

export type PutUserSettingsBySettingKeyErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type PutUserSettingsBySettingKeyError = PutUserSettingsBySettingKeyErrors[keyof PutUserSettingsBySettingKeyErrors];

export type PutUserSettingsBySettingKeyResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PutUserSettingsBySettingKeyResponse = PutUserSettingsBySettingKeyResponses[keyof PutUserSettingsBySettingKeyResponses];

export type GetStockData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/stock';
};

export type GetStockResponses = {
    /**
     * An array of CurrentStockResponse objects
     */
    200: Array<CurrentStockResponse>;
};

export type GetStockResponse = GetStockResponses[keyof GetStockResponses];

export type GetStockEntryByEntryIdData = {
    body?: never;
    path: {
        /**
         * A valid stock entry id
         */
        entryId: number;
    };
    query?: never;
    url: '/stock/entry/{entryId}';
};

export type GetStockEntryByEntryIdErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product)
     */
    400: Error400;
};

export type GetStockEntryByEntryIdError = GetStockEntryByEntryIdErrors[keyof GetStockEntryByEntryIdErrors];

export type GetStockEntryByEntryIdResponses = {
    /**
     * A StockEntry Response object
     */
    200: StockEntry;
};

export type GetStockEntryByEntryIdResponse = GetStockEntryByEntryIdResponses[keyof GetStockEntryByEntryIdResponses];

export type PutStockEntryByEntryIdData = {
    body: {
        /**
         * The amount to add - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
         */
        amount?: number;
        /**
         * The due date of the product to add, when omitted, the current date is used
         */
        best_before_date?: string;
        /**
         * The price per stock quantity unit in configured currency
         */
        price?: number;
        /**
         * If the stock entry was already opened or not
         */
        open?: boolean;
        /**
         * If omitted, the default location of the product is used
         */
        location_id?: number;
        /**
         * If omitted, no store will be affected
         */
        shopping_location_id?: number;
        /**
         * The date when this stock entry was purchased
         */
        purchased_date?: string;
    };
    path: {
        /**
         * A valid stock entry id
         */
        entryId: number;
    };
    query?: never;
    url: '/stock/entry/{entryId}';
};

export type PutStockEntryByEntryIdErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product, invalid transaction type)
     */
    400: Error400;
};

export type PutStockEntryByEntryIdError = PutStockEntryByEntryIdErrors[keyof PutStockEntryByEntryIdErrors];

export type PutStockEntryByEntryIdResponses = {
    /**
     * The operation was successful
     */
    200: Array<StockLogEntry>;
};

export type PutStockEntryByEntryIdResponse = PutStockEntryByEntryIdResponses[keyof PutStockEntryByEntryIdResponses];

export type GetStockEntryByEntryIdPrintlabelData = {
    body?: never;
    path: {
        /**
         * A valid stock entry id
         */
        entryId: number;
    };
    query?: never;
    url: '/stock/entry/{entryId}/printlabel';
};

export type GetStockEntryByEntryIdPrintlabelErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing stock entry, error on WebHook execution)
     */
    400: Error400;
};

export type GetStockEntryByEntryIdPrintlabelError = GetStockEntryByEntryIdPrintlabelErrors[keyof GetStockEntryByEntryIdPrintlabelErrors];

export type GetStockEntryByEntryIdPrintlabelResponses = {
    /**
     * WebHook data
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetStockEntryByEntryIdPrintlabelResponse = GetStockEntryByEntryIdPrintlabelResponses[keyof GetStockEntryByEntryIdPrintlabelResponses];

export type GetStockVolatileData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The number of days in which products are considered to be due soon
         */
        due_soon_days?: number;
    };
    url: '/stock/volatile';
};

export type GetStockVolatileResponses = {
    /**
     * A CurrentVolatilStockResponse object
     */
    200: Array<CurrentVolatilStockResponse>;
};

export type GetStockVolatileResponse = GetStockVolatileResponses[keyof GetStockVolatileResponses];

export type GetStockProductsByProductIdData = {
    body?: never;
    path: {
        /**
         * A valid product id
         */
        productId: number;
    };
    query?: never;
    url: '/stock/products/{productId}';
};

export type GetStockProductsByProductIdErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product)
     */
    400: Error400;
};

export type GetStockProductsByProductIdError = GetStockProductsByProductIdErrors[keyof GetStockProductsByProductIdErrors];

export type GetStockProductsByProductIdResponses = {
    /**
     * A ProductDetailsResponse object
     */
    200: ProductDetailsResponse;
};

export type GetStockProductsByProductIdResponse = GetStockProductsByProductIdResponses[keyof GetStockProductsByProductIdResponses];

export type GetStockProductsByProductIdLocationsData = {
    body?: never;
    path: {
        /**
         * A valid product id
         */
        productId: number;
    };
    query?: {
        /**
         * If sub product locations should be included (if the given product is a parent product and in addition to the ones of the given product)
         */
        include_sub_products?: boolean;
        /**
         * An array of filter conditions, each of them is a string in the form of `<field><condition><value>` where<br>`<field>` is a valid field name<br>`<condition>` is a comparison operator, one of<br>&nbsp;&nbsp;`=` equal<br>&nbsp;&nbsp;`!=` not equal<br>&nbsp;&nbsp;`~` LIKE<br>&nbsp;&nbsp;`!~` not LIKE<br>&nbsp;&nbsp;`<` less<br>&nbsp;&nbsp;`>` greater<br>&nbsp;&nbsp;`<=` less or equal<br>&nbsp;&nbsp;`>=` greater or equal<br>&nbsp;&nbsp;`§` regular expression<br>`<value>` is the value to search for
         */
        'query[]'?: Array<string>;
        /**
         * A valid field name by which the response should be ordered, use the separator `:` to specify the sort order (`asc` or `desc`, defaults to `asc` when omitted)
         */
        order?: string;
        /**
         * The maximum number of objects to return
         */
        limit?: number;
        /**
         * The number of objects to skip
         */
        offset?: number;
    };
    url: '/stock/products/{productId}/locations';
};

export type GetStockProductsByProductIdLocationsErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product)
     */
    400: Error400;
    /**
     * The operation was not successful (possible errors are invalid field names or conditions in filter parameters provided)
     */
    500: Error500;
};

export type GetStockProductsByProductIdLocationsError = GetStockProductsByProductIdLocationsErrors[keyof GetStockProductsByProductIdLocationsErrors];

export type GetStockProductsByProductIdLocationsResponses = {
    /**
     * An array of StockLocation objects
     */
    200: Array<StockLocation>;
};

export type GetStockProductsByProductIdLocationsResponse = GetStockProductsByProductIdLocationsResponses[keyof GetStockProductsByProductIdLocationsResponses];

export type GetStockProductsByProductIdEntriesData = {
    body?: never;
    path: {
        /**
         * A valid product id
         */
        productId: number;
    };
    query?: {
        /**
         * If sub products should be included (if the given product is a parent product and in addition to the ones of the given product)
         */
        include_sub_products?: boolean;
        /**
         * An array of filter conditions, each of them is a string in the form of `<field><condition><value>` where<br>`<field>` is a valid field name<br>`<condition>` is a comparison operator, one of<br>&nbsp;&nbsp;`=` equal<br>&nbsp;&nbsp;`!=` not equal<br>&nbsp;&nbsp;`~` LIKE<br>&nbsp;&nbsp;`!~` not LIKE<br>&nbsp;&nbsp;`<` less<br>&nbsp;&nbsp;`>` greater<br>&nbsp;&nbsp;`<=` less or equal<br>&nbsp;&nbsp;`>=` greater or equal<br>&nbsp;&nbsp;`§` regular expression<br>`<value>` is the value to search for
         */
        'query[]'?: Array<string>;
        /**
         * A valid field name by which the response should be ordered, use the separator `:` to specify the sort order (`asc` or `desc`, defaults to `asc` when omitted)
         */
        order?: string;
        /**
         * The maximum number of objects to return
         */
        limit?: number;
        /**
         * The number of objects to skip
         */
        offset?: number;
    };
    url: '/stock/products/{productId}/entries';
};

export type GetStockProductsByProductIdEntriesErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product)
     */
    400: Error400;
    /**
     * The operation was not successful (possible errors are invalid field names or conditions in filter parameters provided)
     */
    500: Error500;
};

export type GetStockProductsByProductIdEntriesError = GetStockProductsByProductIdEntriesErrors[keyof GetStockProductsByProductIdEntriesErrors];

export type GetStockProductsByProductIdEntriesResponses = {
    /**
     * An array of StockEntry objects
     */
    200: Array<StockEntry>;
};

export type GetStockProductsByProductIdEntriesResponse = GetStockProductsByProductIdEntriesResponses[keyof GetStockProductsByProductIdEntriesResponses];

export type GetStockProductsByProductIdPriceHistoryData = {
    body?: never;
    path: {
        /**
         * A valid product id
         */
        productId: number;
    };
    query?: never;
    url: '/stock/products/{productId}/price-history';
};

export type GetStockProductsByProductIdPriceHistoryErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product)
     */
    400: Error400;
};

export type GetStockProductsByProductIdPriceHistoryError = GetStockProductsByProductIdPriceHistoryErrors[keyof GetStockProductsByProductIdPriceHistoryErrors];

export type GetStockProductsByProductIdPriceHistoryResponses = {
    /**
     * An array of ProductPriceHistory objects
     */
    200: Array<ProductPriceHistory>;
};

export type GetStockProductsByProductIdPriceHistoryResponse = GetStockProductsByProductIdPriceHistoryResponses[keyof GetStockProductsByProductIdPriceHistoryResponses];

export type PostStockProductsByProductIdAddData = {
    body: {
        /**
         * The amount to add - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
         */
        amount?: number;
        /**
         * The due date of the product to add, when omitted, the current date is used
         */
        best_before_date?: string;
        transaction_type?: StockTransactionType;
        /**
         * The price per stock quantity unit in configured currency
         */
        price?: number;
        /**
         * If omitted, the default location of the product is used
         */
        location_id?: number;
        /**
         * If omitted, no store will be affected
         */
        shopping_location_id?: number;
        /**
         * `1` = No label, `2` = Single label, `3` = Label per unit
         */
        stock_label_type?: number;
        /**
         * An optional note for the corresponding stock entry
         */
        note?: string;
    };
    path: {
        /**
         * A valid product id
         */
        productId: number;
    };
    query?: never;
    url: '/stock/products/{productId}/add';
};

export type PostStockProductsByProductIdAddErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product, invalid transaction type)
     */
    400: Error400;
};

export type PostStockProductsByProductIdAddError = PostStockProductsByProductIdAddErrors[keyof PostStockProductsByProductIdAddErrors];

export type PostStockProductsByProductIdAddResponses = {
    /**
     * The operation was successful
     */
    200: Array<StockLogEntry>;
};

export type PostStockProductsByProductIdAddResponse = PostStockProductsByProductIdAddResponses[keyof PostStockProductsByProductIdAddResponses];

export type PostStockProductsByProductIdConsumeData = {
    body: {
        /**
         * The amount to remove - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
         */
        amount?: number;
        transaction_type?: StockTransactionType;
        /**
         * True when the given product was spoiled, defaults to false
         */
        spoiled?: boolean;
        /**
         * A specific stock entry id to consume, if used, the amount has to be 1
         */
        stock_entry_id?: string;
        /**
         * A valid recipe id for which this product was used (for statistical purposes only)
         */
        recipe_id?: number;
        /**
         * A valid location id (if supplied, only stock at the given location is considered, if ommitted, stock of any location is considered)
         */
        location_id?: number;
        /**
         * For tare weight handling enabled products, `true` when the given is the absolute amount to be consumed, not the amount including the container weight
         */
        exact_amount?: boolean;
        /**
         * `true` when any in stock sub product should be used when the given product is a parent product and currently not in stock
         */
        allow_subproduct_substitution?: boolean;
    };
    path: {
        /**
         * A valid product id
         */
        productId: number;
    };
    query?: never;
    url: '/stock/products/{productId}/consume';
};

export type PostStockProductsByProductIdConsumeErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product, invalid transaction type, given amount > current stock amount)
     */
    400: Error400;
};

export type PostStockProductsByProductIdConsumeError = PostStockProductsByProductIdConsumeErrors[keyof PostStockProductsByProductIdConsumeErrors];

export type PostStockProductsByProductIdConsumeResponses = {
    /**
     * The operation was successful
     */
    200: Array<StockLogEntry>;
};

export type PostStockProductsByProductIdConsumeResponse = PostStockProductsByProductIdConsumeResponses[keyof PostStockProductsByProductIdConsumeResponses];

export type PostStockProductsByProductIdTransferData = {
    body: {
        /**
         * The amount to transfer - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
         */
        amount?: number;
        /**
         * A valid location id, the location from where the product should be transfered
         */
        location_id_from?: number;
        /**
         * A valid location id, the location to where the product should be transfered
         */
        location_id_to?: number;
        /**
         * A specific stock entry id to transfer, if used, the amount has to be 1
         */
        stock_entry_id?: string;
    };
    path: {
        /**
         * A valid product id
         */
        productId: number;
    };
    query?: never;
    url: '/stock/products/{productId}/transfer';
};

export type PostStockProductsByProductIdTransferErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product, no existing from or to location, given amount > current stock amount at the source location)
     */
    400: Error400;
};

export type PostStockProductsByProductIdTransferError = PostStockProductsByProductIdTransferErrors[keyof PostStockProductsByProductIdTransferErrors];

export type PostStockProductsByProductIdTransferResponses = {
    /**
     * The operation was successful
     */
    200: Array<StockLogEntry>;
};

export type PostStockProductsByProductIdTransferResponse = PostStockProductsByProductIdTransferResponses[keyof PostStockProductsByProductIdTransferResponses];

export type PostStockProductsByProductIdInventoryData = {
    body: {
        /**
         * The new current amount for the given product - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
         */
        new_amount?: number;
        /**
         * The due date which applies to added products
         */
        best_before_date?: string;
        /**
         * If omitted, no store will be affected
         */
        shopping_location_id?: number;
        /**
         * If omitted, the default location of the product is used (only applies to added products)
         */
        location_id?: number;
        /**
         * If omitted, the last price of the product is used (only applies to added products)
         */
        price?: number;
        /**
         * `1` = No label, `2` = Single label, `3` = Label per unit (only applies to added products)
         */
        stock_label_type?: number;
        /**
         * An optional note for the corresponding stock entry (only applies to added products)
         */
        note?: string;
    };
    path: {
        /**
         * A valid product id
         */
        productId: number;
    };
    query?: never;
    url: '/stock/products/{productId}/inventory';
};

export type PostStockProductsByProductIdInventoryErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product)
     */
    400: Error400;
};

export type PostStockProductsByProductIdInventoryError = PostStockProductsByProductIdInventoryErrors[keyof PostStockProductsByProductIdInventoryErrors];

export type PostStockProductsByProductIdInventoryResponses = {
    /**
     * The operation was successful
     */
    200: Array<StockLogEntry>;
};

export type PostStockProductsByProductIdInventoryResponse = PostStockProductsByProductIdInventoryResponses[keyof PostStockProductsByProductIdInventoryResponses];

export type PostStockProductsByProductIdOpenData = {
    body: {
        /**
         * The amount to mark as opened
         */
        amount?: number;
        /**
         * A specific stock entry id to open, if used, the amount has to be 1
         */
        stock_entry_id?: string;
        /**
         * `true` when any in stock sub product should be used when the given product is a parent product and currently not in stock
         */
        allow_subproduct_substitution?: boolean;
    };
    path: {
        /**
         * A valid product id
         */
        productId: number;
    };
    query?: never;
    url: '/stock/products/{productId}/open';
};

export type PostStockProductsByProductIdOpenErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product, given amount > current unopened stock amount)
     */
    400: Error400;
};

export type PostStockProductsByProductIdOpenError = PostStockProductsByProductIdOpenErrors[keyof PostStockProductsByProductIdOpenErrors];

export type PostStockProductsByProductIdOpenResponses = {
    /**
     * The operation was successful
     */
    200: Array<StockLogEntry>;
};

export type PostStockProductsByProductIdOpenResponse = PostStockProductsByProductIdOpenResponses[keyof PostStockProductsByProductIdOpenResponses];

export type GetStockProductsByProductIdPrintlabelData = {
    body?: never;
    path: {
        /**
         * A valid product id
         */
        productId: number;
    };
    query?: never;
    url: '/stock/products/{productId}/printlabel';
};

export type GetStockProductsByProductIdPrintlabelErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product, error on WebHook execution)
     */
    400: Error400;
};

export type GetStockProductsByProductIdPrintlabelError = GetStockProductsByProductIdPrintlabelErrors[keyof GetStockProductsByProductIdPrintlabelErrors];

export type GetStockProductsByProductIdPrintlabelResponses = {
    /**
     * WebHook data
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetStockProductsByProductIdPrintlabelResponse = GetStockProductsByProductIdPrintlabelResponses[keyof GetStockProductsByProductIdPrintlabelResponses];

export type PostStockProductsByProductIdToKeepMergeByProductIdToRemoveData = {
    body?: never;
    path: {
        /**
         * A valid product id of the product to keep
         */
        productIdToKeep: number;
        /**
         * A valid product id of the product to remove
         */
        productIdToRemove: number;
    };
    query?: never;
    url: '/stock/products/{productIdToKeep}/merge/{productIdToRemove}';
};

export type PostStockProductsByProductIdToKeepMergeByProductIdToRemoveErrors = {
    /**
     * The operation was not successful (possible errors are: Invalid product id)
     */
    400: Error400;
};

export type PostStockProductsByProductIdToKeepMergeByProductIdToRemoveError = PostStockProductsByProductIdToKeepMergeByProductIdToRemoveErrors[keyof PostStockProductsByProductIdToKeepMergeByProductIdToRemoveErrors];

export type PostStockProductsByProductIdToKeepMergeByProductIdToRemoveResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostStockProductsByProductIdToKeepMergeByProductIdToRemoveResponse = PostStockProductsByProductIdToKeepMergeByProductIdToRemoveResponses[keyof PostStockProductsByProductIdToKeepMergeByProductIdToRemoveResponses];

export type GetStockProductsByBarcodeByBarcodeData = {
    body?: never;
    path: {
        /**
         * Barcode
         */
        barcode: string;
    };
    query?: never;
    url: '/stock/products/by-barcode/{barcode}';
};

export type GetStockProductsByBarcodeByBarcodeErrors = {
    /**
     * The operation was not successful (possible errors are: Unknown barcode)
     */
    400: Error400;
};

export type GetStockProductsByBarcodeByBarcodeError = GetStockProductsByBarcodeByBarcodeErrors[keyof GetStockProductsByBarcodeByBarcodeErrors];

export type GetStockProductsByBarcodeByBarcodeResponses = {
    /**
     * A ProductDetailsResponse object
     */
    200: ProductDetailsResponse;
};

export type GetStockProductsByBarcodeByBarcodeResponse = GetStockProductsByBarcodeByBarcodeResponses[keyof GetStockProductsByBarcodeByBarcodeResponses];

export type PostStockProductsByBarcodeByBarcodeAddData = {
    body: {
        /**
         * The amount to add - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
         */
        amount?: number;
        /**
         * The due date of the product to add, when omitted, the current date is used
         */
        best_before_date?: string;
        transaction_type?: StockTransactionType;
        /**
         * The price per stock quantity unit in configured currency
         */
        price?: number;
        /**
         * If omitted, the default location of the product is used
         */
        location_id?: number;
    };
    path: {
        /**
         * Barcode
         */
        barcode: string;
    };
    query?: never;
    url: '/stock/products/by-barcode/{barcode}/add';
};

export type PostStockProductsByBarcodeByBarcodeAddErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product, invalid transaction type)
     */
    400: Error400;
};

export type PostStockProductsByBarcodeByBarcodeAddError = PostStockProductsByBarcodeByBarcodeAddErrors[keyof PostStockProductsByBarcodeByBarcodeAddErrors];

export type PostStockProductsByBarcodeByBarcodeAddResponses = {
    /**
     * The operation was successful
     */
    200: Array<StockLogEntry>;
};

export type PostStockProductsByBarcodeByBarcodeAddResponse = PostStockProductsByBarcodeByBarcodeAddResponses[keyof PostStockProductsByBarcodeByBarcodeAddResponses];

export type PostStockProductsByBarcodeByBarcodeConsumeData = {
    body: {
        /**
         * The amount to remove - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
         */
        amount?: number;
        transaction_type?: StockTransactionType;
        /**
         * True when the given product was spoiled, defaults to false
         */
        spoiled?: boolean;
        /**
         * A specific stock entry id to consume, if used, the amount has to be 1
         */
        stock_entry_id?: string;
        /**
         * A valid recipe id for which this product was used (for statistical purposes only)
         */
        recipe_id?: number;
        /**
         * A valid location id (if supplied, only stock at the given location is considered, if ommitted, stock of any location is considered)
         */
        location_id?: number;
        /**
         * For tare weight handling enabled products, `true` when the given is the absolute amount to be consumed, not the amount including the container weight
         */
        exact_amount?: boolean;
        /**
         * `rue` when any in stock sub product should be used when the given product is a parent product and currently not in stock
         */
        allow_subproduct_substitution?: boolean;
    };
    path: {
        /**
         * Barcode
         */
        barcode: string;
    };
    query?: never;
    url: '/stock/products/by-barcode/{barcode}/consume';
};

export type PostStockProductsByBarcodeByBarcodeConsumeErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product, invalid transaction type, given amount > current stock amount)
     */
    400: Error400;
};

export type PostStockProductsByBarcodeByBarcodeConsumeError = PostStockProductsByBarcodeByBarcodeConsumeErrors[keyof PostStockProductsByBarcodeByBarcodeConsumeErrors];

export type PostStockProductsByBarcodeByBarcodeConsumeResponses = {
    /**
     * The operation was successful
     */
    200: Array<StockLogEntry>;
};

export type PostStockProductsByBarcodeByBarcodeConsumeResponse = PostStockProductsByBarcodeByBarcodeConsumeResponses[keyof PostStockProductsByBarcodeByBarcodeConsumeResponses];

export type PostStockProductsByBarcodeByBarcodeTransferData = {
    body: {
        /**
         * The amount to transfer - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
         */
        amount?: number;
        /**
         * A valid location id, the location from where the product should be transfered
         */
        location_id_from?: number;
        /**
         * A valid location id, the location to where the product should be transfered
         */
        location_id_to?: number;
        /**
         * A specific stock entry id to transfer, if used, the amount has to be 1
         */
        stock_entry_id?: string;
    };
    path: {
        /**
         * Barcode
         */
        barcode: string;
    };
    query?: never;
    url: '/stock/products/by-barcode/{barcode}/transfer';
};

export type PostStockProductsByBarcodeByBarcodeTransferErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product, no existing from or to location, given amount > current stock amount at the source location)
     */
    400: Error400;
};

export type PostStockProductsByBarcodeByBarcodeTransferError = PostStockProductsByBarcodeByBarcodeTransferErrors[keyof PostStockProductsByBarcodeByBarcodeTransferErrors];

export type PostStockProductsByBarcodeByBarcodeTransferResponses = {
    /**
     * The operation was successful
     */
    200: Array<StockLogEntry>;
};

export type PostStockProductsByBarcodeByBarcodeTransferResponse = PostStockProductsByBarcodeByBarcodeTransferResponses[keyof PostStockProductsByBarcodeByBarcodeTransferResponses];

export type PostStockProductsByBarcodeByBarcodeInventoryData = {
    body: {
        /**
         * The new current amount for the given product - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
         */
        new_amount?: number;
        /**
         * The due date which applies to added products
         */
        best_before_date?: string;
        /**
         * If omitted, the default location of the product is used (only applies to added products)
         */
        location_id?: number;
        /**
         * If omitted, the last price of the product is used (only applies to added products)
         */
        price?: number;
    };
    path: {
        /**
         * Barcode
         */
        barcode: string;
    };
    query?: never;
    url: '/stock/products/by-barcode/{barcode}/inventory';
};

export type PostStockProductsByBarcodeByBarcodeInventoryErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product)
     */
    400: Error400;
};

export type PostStockProductsByBarcodeByBarcodeInventoryError = PostStockProductsByBarcodeByBarcodeInventoryErrors[keyof PostStockProductsByBarcodeByBarcodeInventoryErrors];

export type PostStockProductsByBarcodeByBarcodeInventoryResponses = {
    /**
     * The operation was successful
     */
    200: Array<StockLogEntry>;
};

export type PostStockProductsByBarcodeByBarcodeInventoryResponse = PostStockProductsByBarcodeByBarcodeInventoryResponses[keyof PostStockProductsByBarcodeByBarcodeInventoryResponses];

export type PostStockProductsByBarcodeByBarcodeOpenData = {
    body: {
        /**
         * The amount to mark as opened
         */
        amount?: number;
        /**
         * A specific stock entry id to open, if used, the amount has to be 1
         */
        stock_entry_id?: string;
        /**
         * `rue` when any in stock sub product should be used when the given product is a parent product and currently not in stock
         */
        allow_subproduct_substitution?: boolean;
    };
    path: {
        /**
         * Barcode
         */
        barcode: string;
    };
    query?: never;
    url: '/stock/products/by-barcode/{barcode}/open';
};

export type PostStockProductsByBarcodeByBarcodeOpenErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing product, given amount > current unopened stock amount)
     */
    400: Error400;
};

export type PostStockProductsByBarcodeByBarcodeOpenError = PostStockProductsByBarcodeByBarcodeOpenErrors[keyof PostStockProductsByBarcodeByBarcodeOpenErrors];

export type PostStockProductsByBarcodeByBarcodeOpenResponses = {
    /**
     * The operation was successful
     */
    200: Array<StockLogEntry>;
};

export type PostStockProductsByBarcodeByBarcodeOpenResponse = PostStockProductsByBarcodeByBarcodeOpenResponses[keyof PostStockProductsByBarcodeByBarcodeOpenResponses];

export type GetStockLocationsByLocationIdEntriesData = {
    body?: never;
    path: {
        /**
         * A valid location id
         */
        locationId: number;
    };
    query?: {
        /**
         * An array of filter conditions, each of them is a string in the form of `<field><condition><value>` where<br>`<field>` is a valid field name<br>`<condition>` is a comparison operator, one of<br>&nbsp;&nbsp;`=` equal<br>&nbsp;&nbsp;`!=` not equal<br>&nbsp;&nbsp;`~` LIKE<br>&nbsp;&nbsp;`!~` not LIKE<br>&nbsp;&nbsp;`<` less<br>&nbsp;&nbsp;`>` greater<br>&nbsp;&nbsp;`<=` less or equal<br>&nbsp;&nbsp;`>=` greater or equal<br>&nbsp;&nbsp;`§` regular expression<br>`<value>` is the value to search for
         */
        'query[]'?: Array<string>;
        /**
         * A valid field name by which the response should be ordered, use the separator `:` to specify the sort order (`asc` or `desc`, defaults to `asc` when omitted)
         */
        order?: string;
        /**
         * The maximum number of objects to return
         */
        limit?: number;
        /**
         * The number of objects to skip
         */
        offset?: number;
    };
    url: '/stock/locations/{locationId}/entries';
};

export type GetStockLocationsByLocationIdEntriesErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing location)
     */
    400: Error400;
    /**
     * The operation was not successful (possible errors are invalid field names or conditions in filter parameters provided)
     */
    500: Error500;
};

export type GetStockLocationsByLocationIdEntriesError = GetStockLocationsByLocationIdEntriesErrors[keyof GetStockLocationsByLocationIdEntriesErrors];

export type GetStockLocationsByLocationIdEntriesResponses = {
    /**
     * An array of StockEntry objects
     */
    200: Array<StockEntry>;
};

export type GetStockLocationsByLocationIdEntriesResponse = GetStockLocationsByLocationIdEntriesResponses[keyof GetStockLocationsByLocationIdEntriesResponses];

export type PostStockShoppinglistAddMissingProductsData = {
    body?: {
        /**
         * The shopping list to use, when omitted, the default shopping list (with id 1) is used
         */
        list_id?: number;
    };
    path?: never;
    query?: never;
    url: '/stock/shoppinglist/add-missing-products';
};

export type PostStockShoppinglistAddMissingProductsErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing shopping list)
     */
    400: Error400;
};

export type PostStockShoppinglistAddMissingProductsError = PostStockShoppinglistAddMissingProductsErrors[keyof PostStockShoppinglistAddMissingProductsErrors];

export type PostStockShoppinglistAddMissingProductsResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostStockShoppinglistAddMissingProductsResponse = PostStockShoppinglistAddMissingProductsResponses[keyof PostStockShoppinglistAddMissingProductsResponses];

export type PostStockShoppinglistAddOverdueProductsData = {
    body?: {
        /**
         * The shopping list to use, when omitted, the default shopping list (with id 1) is used
         */
        list_id?: number;
    };
    path?: never;
    query?: never;
    url: '/stock/shoppinglist/add-overdue-products';
};

export type PostStockShoppinglistAddOverdueProductsErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing shopping list)
     */
    400: Error400;
};

export type PostStockShoppinglistAddOverdueProductsError = PostStockShoppinglistAddOverdueProductsErrors[keyof PostStockShoppinglistAddOverdueProductsErrors];

export type PostStockShoppinglistAddOverdueProductsResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostStockShoppinglistAddOverdueProductsResponse = PostStockShoppinglistAddOverdueProductsResponses[keyof PostStockShoppinglistAddOverdueProductsResponses];

export type PostStockShoppinglistAddExpiredProductsData = {
    body?: {
        /**
         * The shopping list to use, when omitted, the default shopping list (with id 1) is used
         */
        list_id?: number;
    };
    path?: never;
    query?: never;
    url: '/stock/shoppinglist/add-expired-products';
};

export type PostStockShoppinglistAddExpiredProductsErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing shopping list)
     */
    400: Error400;
};

export type PostStockShoppinglistAddExpiredProductsError = PostStockShoppinglistAddExpiredProductsErrors[keyof PostStockShoppinglistAddExpiredProductsErrors];

export type PostStockShoppinglistAddExpiredProductsResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostStockShoppinglistAddExpiredProductsResponse = PostStockShoppinglistAddExpiredProductsResponses[keyof PostStockShoppinglistAddExpiredProductsResponses];

export type PostStockShoppinglistClearData = {
    body?: {
        /**
         * The shopping list id to clear, when omitted, the default shopping list (with id 1) is used
         */
        list_id?: number;
        /**
         * When `true`, only done items will be removed (defaults to `false` when ommited)
         */
        done_only?: boolean;
    };
    path?: never;
    query?: never;
    url: '/stock/shoppinglist/clear';
};

export type PostStockShoppinglistClearErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing shopping list)
     */
    400: Error400;
};

export type PostStockShoppinglistClearError = PostStockShoppinglistClearErrors[keyof PostStockShoppinglistClearErrors];

export type PostStockShoppinglistClearResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostStockShoppinglistClearResponse = PostStockShoppinglistClearResponses[keyof PostStockShoppinglistClearResponses];

export type PostStockShoppinglistAddProductData = {
    body: {
        /**
         * A valid product id of the product to be added
         */
        product_id?: number;
        /**
         * A valid quantity unit id (used only for display; the amount needs to be related to the products stock QU), when omitted, the products stock QU is used
         */
        qu_id?: number;
        /**
         * A valid shopping list id, when omitted, the default shopping list (with id 1) is used
         */
        list_id?: number;
        /**
         * The amount (related to the products stock QU) to add, when omitted, the default amount of 1 is used
         */
        product_amount?: number;
        /**
         * The note of the shopping list item
         */
        note?: string;
    };
    path?: never;
    query?: never;
    url: '/stock/shoppinglist/add-product';
};

export type PostStockShoppinglistAddProductErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing shopping list, Invalid product id supplied)
     */
    400: Error400;
};

export type PostStockShoppinglistAddProductError = PostStockShoppinglistAddProductErrors[keyof PostStockShoppinglistAddProductErrors];

export type PostStockShoppinglistAddProductResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostStockShoppinglistAddProductResponse = PostStockShoppinglistAddProductResponses[keyof PostStockShoppinglistAddProductResponses];

export type PostStockShoppinglistRemoveProductData = {
    body: {
        /**
         * A valid product id of the item on the shopping list
         */
        product_id?: number;
        /**
         * A valid shopping list id, when omitted, the default shopping list (with id 1) is used
         */
        list_id?: number;
        /**
         * The amount of product units to remove, when omitted, the default amount of 1 is used
         */
        product_amount?: number;
    };
    path?: never;
    query?: never;
    url: '/stock/shoppinglist/remove-product';
};

export type PostStockShoppinglistRemoveProductErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing shopping list, Invalid product id supplied)
     */
    400: Error400;
};

export type PostStockShoppinglistRemoveProductError = PostStockShoppinglistRemoveProductErrors[keyof PostStockShoppinglistRemoveProductErrors];

export type PostStockShoppinglistRemoveProductResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostStockShoppinglistRemoveProductResponse = PostStockShoppinglistRemoveProductResponses[keyof PostStockShoppinglistRemoveProductResponses];

export type GetStockBookingsByBookingIdData = {
    body?: never;
    path: {
        /**
         * A valid stock booking id
         */
        bookingId: number;
    };
    query?: never;
    url: '/stock/bookings/{bookingId}';
};

export type GetStockBookingsByBookingIdErrors = {
    /**
     * The operation was not successful (possible errors are: Invalid stock booking id)
     */
    400: Error400;
};

export type GetStockBookingsByBookingIdError = GetStockBookingsByBookingIdErrors[keyof GetStockBookingsByBookingIdErrors];

export type GetStockBookingsByBookingIdResponses = {
    /**
     * A StockLogEntry object
     */
    200: StockLogEntry;
};

export type GetStockBookingsByBookingIdResponse = GetStockBookingsByBookingIdResponses[keyof GetStockBookingsByBookingIdResponses];

export type PostStockBookingsByBookingIdUndoData = {
    body?: never;
    path: {
        /**
         * A valid stock booking id
         */
        bookingId: number;
    };
    query?: never;
    url: '/stock/bookings/{bookingId}/undo';
};

export type PostStockBookingsByBookingIdUndoErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing booking)
     */
    400: Error400;
};

export type PostStockBookingsByBookingIdUndoError = PostStockBookingsByBookingIdUndoErrors[keyof PostStockBookingsByBookingIdUndoErrors];

export type PostStockBookingsByBookingIdUndoResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostStockBookingsByBookingIdUndoResponse = PostStockBookingsByBookingIdUndoResponses[keyof PostStockBookingsByBookingIdUndoResponses];

export type GetStockTransactionsByTransactionIdData = {
    body?: never;
    path: {
        /**
         * A valid stock transaction id
         */
        transactionId: string;
    };
    query?: never;
    url: '/stock/transactions/{transactionId}';
};

export type GetStockTransactionsByTransactionIdErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing transaction)
     */
    400: Error400;
};

export type GetStockTransactionsByTransactionIdError = GetStockTransactionsByTransactionIdErrors[keyof GetStockTransactionsByTransactionIdErrors];

export type GetStockTransactionsByTransactionIdResponses = {
    /**
     * An array of StockLogEntry objects
     */
    200: Array<StockLogEntry>;
};

export type GetStockTransactionsByTransactionIdResponse = GetStockTransactionsByTransactionIdResponses[keyof GetStockTransactionsByTransactionIdResponses];

export type PostStockTransactionsByTransactionIdUndoData = {
    body?: never;
    path: {
        /**
         * A valid stock transaction id
         */
        transactionId: string;
    };
    query?: never;
    url: '/stock/transactions/{transactionId}/undo';
};

export type PostStockTransactionsByTransactionIdUndoErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing transaction)
     */
    400: Error400;
};

export type PostStockTransactionsByTransactionIdUndoError = PostStockTransactionsByTransactionIdUndoErrors[keyof PostStockTransactionsByTransactionIdUndoErrors];

export type PostStockTransactionsByTransactionIdUndoResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostStockTransactionsByTransactionIdUndoResponse = PostStockTransactionsByTransactionIdUndoResponses[keyof PostStockTransactionsByTransactionIdUndoResponses];

export type GetStockBarcodesExternalLookupByBarcodeData = {
    body?: never;
    path: {
        /**
         * The barcode to lookup up
         */
        barcode: string;
    };
    query?: {
        /**
         * When true, the product is added to the database on a successful lookup and the new product id is in included in the response
         */
        add?: boolean;
    };
    url: '/stock/barcodes/external-lookup/{barcode}';
};

export type GetStockBarcodesExternalLookupByBarcodeErrors = {
    /**
     * The operation was not successful (possible errors are: Plugin error)
     */
    400: Error400;
};

export type GetStockBarcodesExternalLookupByBarcodeError = GetStockBarcodesExternalLookupByBarcodeErrors[keyof GetStockBarcodesExternalLookupByBarcodeErrors];

export type GetStockBarcodesExternalLookupByBarcodeResponses = {
    /**
     * An ExternalBarcodeLookupResponse object or null, when nothing was found for the given barcode
     */
    200: ExternalBarcodeLookupResponse;
};

export type GetStockBarcodesExternalLookupByBarcodeResponse = GetStockBarcodesExternalLookupByBarcodeResponses[keyof GetStockBarcodesExternalLookupByBarcodeResponses];

export type PostRecipesByRecipeIdAddNotFulfilledProductsToShoppinglistData = {
    body?: {
        /**
         * An optional array of product ids to exclude them from being put on the shopping list
         */
        excludedProductIds?: Array<number>;
    };
    path: {
        /**
         * A valid recipe id
         */
        recipeId: string;
    };
    query?: never;
    url: '/recipes/{recipeId}/add-not-fulfilled-products-to-shoppinglist';
};

export type PostRecipesByRecipeIdAddNotFulfilledProductsToShoppinglistResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostRecipesByRecipeIdAddNotFulfilledProductsToShoppinglistResponse = PostRecipesByRecipeIdAddNotFulfilledProductsToShoppinglistResponses[keyof PostRecipesByRecipeIdAddNotFulfilledProductsToShoppinglistResponses];

export type GetRecipesByRecipeIdFulfillmentData = {
    body?: never;
    path: {
        /**
         * A valid recipe id
         */
        recipeId: string;
    };
    query?: never;
    url: '/recipes/{recipeId}/fulfillment';
};

export type GetRecipesByRecipeIdFulfillmentErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type GetRecipesByRecipeIdFulfillmentError = GetRecipesByRecipeIdFulfillmentErrors[keyof GetRecipesByRecipeIdFulfillmentErrors];

export type GetRecipesByRecipeIdFulfillmentResponses = {
    /**
     * A RecipeFulfillmentResponse object
     */
    200: RecipeFulfillmentResponse;
};

export type GetRecipesByRecipeIdFulfillmentResponse = GetRecipesByRecipeIdFulfillmentResponses[keyof GetRecipesByRecipeIdFulfillmentResponses];

export type PostRecipesByRecipeIdConsumeData = {
    body?: never;
    path: {
        /**
         * A valid recipe id
         */
        recipeId: string;
    };
    query?: never;
    url: '/recipes/{recipeId}/consume';
};

export type PostRecipesByRecipeIdConsumeErrors = {
    /**
     * The operation was not successful (possible errors are: Invalid recipe id, recipe need is not fulfilled)
     */
    400: Error400;
};

export type PostRecipesByRecipeIdConsumeError = PostRecipesByRecipeIdConsumeErrors[keyof PostRecipesByRecipeIdConsumeErrors];

export type PostRecipesByRecipeIdConsumeResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostRecipesByRecipeIdConsumeResponse = PostRecipesByRecipeIdConsumeResponses[keyof PostRecipesByRecipeIdConsumeResponses];

export type GetRecipesFulfillmentData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * An array of filter conditions, each of them is a string in the form of `<field><condition><value>` where<br>`<field>` is a valid field name<br>`<condition>` is a comparison operator, one of<br>&nbsp;&nbsp;`=` equal<br>&nbsp;&nbsp;`!=` not equal<br>&nbsp;&nbsp;`~` LIKE<br>&nbsp;&nbsp;`!~` not LIKE<br>&nbsp;&nbsp;`<` less<br>&nbsp;&nbsp;`>` greater<br>&nbsp;&nbsp;`<=` less or equal<br>&nbsp;&nbsp;`>=` greater or equal<br>&nbsp;&nbsp;`§` regular expression<br>`<value>` is the value to search for
         */
        'query[]'?: Array<string>;
        /**
         * A valid field name by which the response should be ordered, use the separator `:` to specify the sort order (`asc` or `desc`, defaults to `asc` when omitted)
         */
        order?: string;
        /**
         * The maximum number of objects to return
         */
        limit?: number;
        /**
         * The number of objects to skip
         */
        offset?: number;
    };
    url: '/recipes/fulfillment';
};

export type GetRecipesFulfillmentErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
    /**
     * The operation was not successful (possible errors are invalid field names or conditions in filter parameters provided)
     */
    500: Error500;
};

export type GetRecipesFulfillmentError = GetRecipesFulfillmentErrors[keyof GetRecipesFulfillmentErrors];

export type GetRecipesFulfillmentResponses = {
    /**
     * An array of RecipeFulfillmentResponse objects
     */
    200: Array<RecipeFulfillmentResponse>;
};

export type GetRecipesFulfillmentResponse = GetRecipesFulfillmentResponses[keyof GetRecipesFulfillmentResponses];

export type PostRecipesByRecipeIdCopyData = {
    body?: never;
    path: {
        /**
         * A valid recipe id of the recipe to copy
         */
        recipeId: number;
    };
    query?: never;
    url: '/recipes/{recipeId}/copy';
};

export type PostRecipesByRecipeIdCopyErrors = {
    /**
     * The operation was not successful (possible errors are: Invalid recipe id)
     */
    400: Error400;
};

export type PostRecipesByRecipeIdCopyError = PostRecipesByRecipeIdCopyErrors[keyof PostRecipesByRecipeIdCopyErrors];

export type PostRecipesByRecipeIdCopyResponses = {
    /**
     * The operation was successful
     */
    200: {
        /**
         * The id of the created recipe
         */
        created_object_id?: number;
    };
};

export type PostRecipesByRecipeIdCopyResponse = PostRecipesByRecipeIdCopyResponses[keyof PostRecipesByRecipeIdCopyResponses];

export type GetRecipesByRecipeIdPrintlabelData = {
    body?: never;
    path: {
        /**
         * A valid recipe id
         */
        recipeId: number;
    };
    query?: never;
    url: '/recipes/{recipeId}/printlabel';
};

export type GetRecipesByRecipeIdPrintlabelErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing recipe, error on WebHook execution)
     */
    400: Error400;
};

export type GetRecipesByRecipeIdPrintlabelError = GetRecipesByRecipeIdPrintlabelErrors[keyof GetRecipesByRecipeIdPrintlabelErrors];

export type GetRecipesByRecipeIdPrintlabelResponses = {
    /**
     * WebHook data
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetRecipesByRecipeIdPrintlabelResponse = GetRecipesByRecipeIdPrintlabelResponses[keyof GetRecipesByRecipeIdPrintlabelResponses];

export type GetChoresData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * An array of filter conditions, each of them is a string in the form of `<field><condition><value>` where<br>`<field>` is a valid field name<br>`<condition>` is a comparison operator, one of<br>&nbsp;&nbsp;`=` equal<br>&nbsp;&nbsp;`!=` not equal<br>&nbsp;&nbsp;`~` LIKE<br>&nbsp;&nbsp;`!~` not LIKE<br>&nbsp;&nbsp;`<` less<br>&nbsp;&nbsp;`>` greater<br>&nbsp;&nbsp;`<=` less or equal<br>&nbsp;&nbsp;`>=` greater or equal<br>&nbsp;&nbsp;`§` regular expression<br>`<value>` is the value to search for
         */
        'query[]'?: Array<string>;
        /**
         * A valid field name by which the response should be ordered, use the separator `:` to specify the sort order (`asc` or `desc`, defaults to `asc` when omitted)
         */
        order?: string;
        /**
         * The maximum number of objects to return
         */
        limit?: number;
        /**
         * The number of objects to skip
         */
        offset?: number;
    };
    url: '/chores';
};

export type GetChoresErrors = {
    /**
     * The operation was not successful (possible errors are invalid field names or conditions in filter parameters provided)
     */
    500: Error500;
};

export type GetChoresError = GetChoresErrors[keyof GetChoresErrors];

export type GetChoresResponses = {
    /**
     * An array of CurrentChoreResponse objects
     */
    200: Array<CurrentChoreResponse>;
};

export type GetChoresResponse = GetChoresResponses[keyof GetChoresResponses];

export type GetChoresByChoreIdData = {
    body?: never;
    path: {
        /**
         * A valid chore id
         */
        choreId: number;
    };
    query?: never;
    url: '/chores/{choreId}';
};

export type GetChoresByChoreIdErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing chore)
     */
    400: Error400;
};

export type GetChoresByChoreIdError = GetChoresByChoreIdErrors[keyof GetChoresByChoreIdErrors];

export type GetChoresByChoreIdResponses = {
    /**
     * A ChoreDetailsResponse object
     */
    200: ChoreDetailsResponse;
};

export type GetChoresByChoreIdResponse = GetChoresByChoreIdResponses[keyof GetChoresByChoreIdResponses];

export type PostChoresByChoreIdExecuteData = {
    body: {
        /**
         * The time of when the chore was executed, when omitted, the current time is used
         */
        tracked_time?: string;
        /**
         * A valid user id of who executed this chore, when omitted, the currently authenticated user will be used
         */
        done_by?: number;
        /**
         * `true` when the execution should be tracked as skipped, defaults to `false` when omitted
         */
        skipped?: boolean;
    };
    path: {
        /**
         * A valid chore id
         */
        choreId: number;
    };
    query?: never;
    url: '/chores/{choreId}/execute';
};

export type PostChoresByChoreIdExecuteErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing chore)
     */
    400: Error400;
};

export type PostChoresByChoreIdExecuteError = PostChoresByChoreIdExecuteErrors[keyof PostChoresByChoreIdExecuteErrors];

export type PostChoresByChoreIdExecuteResponses = {
    /**
     * The operation was successful
     */
    200: ChoreLogEntry;
};

export type PostChoresByChoreIdExecuteResponse = PostChoresByChoreIdExecuteResponses[keyof PostChoresByChoreIdExecuteResponses];

export type PostChoresExecutionsByExecutionIdUndoData = {
    body?: never;
    path: {
        /**
         * A valid chore execution id
         */
        executionId: number;
    };
    query?: never;
    url: '/chores/executions/{executionId}/undo';
};

export type PostChoresExecutionsByExecutionIdUndoErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing booking)
     */
    400: Error400;
};

export type PostChoresExecutionsByExecutionIdUndoError = PostChoresExecutionsByExecutionIdUndoErrors[keyof PostChoresExecutionsByExecutionIdUndoErrors];

export type PostChoresExecutionsByExecutionIdUndoResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostChoresExecutionsByExecutionIdUndoResponse = PostChoresExecutionsByExecutionIdUndoResponses[keyof PostChoresExecutionsByExecutionIdUndoResponses];

export type PostChoresExecutionsCalculateNextAssignmentsData = {
    body?: {
        /**
         * The chore id of the chore which next user assignment should be (re)calculated, when omitted, the next user assignments of all chores will (re)caluclated
         */
        chore_id?: number;
    };
    path?: never;
    query?: never;
    url: '/chores/executions/calculate-next-assignments';
};

export type PostChoresExecutionsCalculateNextAssignmentsErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type PostChoresExecutionsCalculateNextAssignmentsError = PostChoresExecutionsCalculateNextAssignmentsErrors[keyof PostChoresExecutionsCalculateNextAssignmentsErrors];

export type PostChoresExecutionsCalculateNextAssignmentsResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostChoresExecutionsCalculateNextAssignmentsResponse = PostChoresExecutionsCalculateNextAssignmentsResponses[keyof PostChoresExecutionsCalculateNextAssignmentsResponses];

export type GetChoresByChoreIdPrintlabelData = {
    body?: never;
    path: {
        /**
         * A valid chore id
         */
        choreId: number;
    };
    query?: never;
    url: '/chores/{choreId}/printlabel';
};

export type GetChoresByChoreIdPrintlabelErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing chore, error on WebHook execution)
     */
    400: Error400;
};

export type GetChoresByChoreIdPrintlabelError = GetChoresByChoreIdPrintlabelErrors[keyof GetChoresByChoreIdPrintlabelErrors];

export type GetChoresByChoreIdPrintlabelResponses = {
    /**
     * WebHook data
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetChoresByChoreIdPrintlabelResponse = GetChoresByChoreIdPrintlabelResponses[keyof GetChoresByChoreIdPrintlabelResponses];

export type PostChoresByChoreIdToKeepMergeByChoreIdToRemoveData = {
    body?: never;
    path: {
        /**
         * A valid chore id of the chore to keep
         */
        choreIdToKeep: number;
        /**
         * A valid chore id of the chore to remove
         */
        choreIdToRemove: number;
    };
    query?: never;
    url: '/chores/{choreIdToKeep}/merge/{choreIdToRemove}';
};

export type PostChoresByChoreIdToKeepMergeByChoreIdToRemoveErrors = {
    /**
     * The operation was not successful (possible errors are: Invalid chore id)
     */
    400: Error400;
};

export type PostChoresByChoreIdToKeepMergeByChoreIdToRemoveError = PostChoresByChoreIdToKeepMergeByChoreIdToRemoveErrors[keyof PostChoresByChoreIdToKeepMergeByChoreIdToRemoveErrors];

export type PostChoresByChoreIdToKeepMergeByChoreIdToRemoveResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostChoresByChoreIdToKeepMergeByChoreIdToRemoveResponse = PostChoresByChoreIdToKeepMergeByChoreIdToRemoveResponses[keyof PostChoresByChoreIdToKeepMergeByChoreIdToRemoveResponses];

export type GetBatteriesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * An array of filter conditions, each of them is a string in the form of `<field><condition><value>` where<br>`<field>` is a valid field name<br>`<condition>` is a comparison operator, one of<br>&nbsp;&nbsp;`=` equal<br>&nbsp;&nbsp;`!=` not equal<br>&nbsp;&nbsp;`~` LIKE<br>&nbsp;&nbsp;`!~` not LIKE<br>&nbsp;&nbsp;`<` less<br>&nbsp;&nbsp;`>` greater<br>&nbsp;&nbsp;`<=` less or equal<br>&nbsp;&nbsp;`>=` greater or equal<br>&nbsp;&nbsp;`§` regular expression<br>`<value>` is the value to search for
         */
        'query[]'?: Array<string>;
        /**
         * A valid field name by which the response should be ordered, use the separator `:` to specify the sort order (`asc` or `desc`, defaults to `asc` when omitted)
         */
        order?: string;
        /**
         * The maximum number of objects to return
         */
        limit?: number;
        /**
         * The number of objects to skip
         */
        offset?: number;
    };
    url: '/batteries';
};

export type GetBatteriesErrors = {
    /**
     * The operation was not successful (possible errors are invalid field names or conditions in filter parameters provided)
     */
    500: Error500;
};

export type GetBatteriesError = GetBatteriesErrors[keyof GetBatteriesErrors];

export type GetBatteriesResponses = {
    /**
     * An array of CurrentBatteryResponse objects
     */
    200: Array<CurrentBatteryResponse>;
};

export type GetBatteriesResponse = GetBatteriesResponses[keyof GetBatteriesResponses];

export type GetBatteriesByBatteryIdData = {
    body?: never;
    path: {
        /**
         * A valid battery id
         */
        batteryId: number;
    };
    query?: never;
    url: '/batteries/{batteryId}';
};

export type GetBatteriesByBatteryIdErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing battery)
     */
    400: Error400;
};

export type GetBatteriesByBatteryIdError = GetBatteriesByBatteryIdErrors[keyof GetBatteriesByBatteryIdErrors];

export type GetBatteriesByBatteryIdResponses = {
    /**
     * A BatteryDetailsResponse object
     */
    200: BatteryDetailsResponse;
};

export type GetBatteriesByBatteryIdResponse = GetBatteriesByBatteryIdResponses[keyof GetBatteriesByBatteryIdResponses];

export type PostBatteriesByBatteryIdChargeData = {
    body: {
        /**
         * The time of when the battery was charged, when omitted, the current time is used
         */
        tracked_time?: string;
    };
    path: {
        /**
         * A valid battery id
         */
        batteryId: number;
    };
    query?: never;
    url: '/batteries/{batteryId}/charge';
};

export type PostBatteriesByBatteryIdChargeErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing battery)
     */
    400: Error400;
};

export type PostBatteriesByBatteryIdChargeError = PostBatteriesByBatteryIdChargeErrors[keyof PostBatteriesByBatteryIdChargeErrors];

export type PostBatteriesByBatteryIdChargeResponses = {
    /**
     * The operation was successful
     */
    200: BatteryChargeCycleEntry;
};

export type PostBatteriesByBatteryIdChargeResponse = PostBatteriesByBatteryIdChargeResponses[keyof PostBatteriesByBatteryIdChargeResponses];

export type PostBatteriesChargeCyclesByChargeCycleIdUndoData = {
    body?: never;
    path: {
        /**
         * A valid charge cycle id
         */
        chargeCycleId: number;
    };
    query?: never;
    url: '/batteries/charge-cycles/{chargeCycleId}/undo';
};

export type PostBatteriesChargeCyclesByChargeCycleIdUndoErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing booking)
     */
    400: Error400;
};

export type PostBatteriesChargeCyclesByChargeCycleIdUndoError = PostBatteriesChargeCyclesByChargeCycleIdUndoErrors[keyof PostBatteriesChargeCyclesByChargeCycleIdUndoErrors];

export type PostBatteriesChargeCyclesByChargeCycleIdUndoResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostBatteriesChargeCyclesByChargeCycleIdUndoResponse = PostBatteriesChargeCyclesByChargeCycleIdUndoResponses[keyof PostBatteriesChargeCyclesByChargeCycleIdUndoResponses];

export type GetBatteriesByBatteryIdPrintlabelData = {
    body?: never;
    path: {
        /**
         * A valid battery id
         */
        batteryId: number;
    };
    query?: never;
    url: '/batteries/{batteryId}/printlabel';
};

export type GetBatteriesByBatteryIdPrintlabelErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing battery, error on WebHook execution)
     */
    400: Error400;
};

export type GetBatteriesByBatteryIdPrintlabelError = GetBatteriesByBatteryIdPrintlabelErrors[keyof GetBatteriesByBatteryIdPrintlabelErrors];

export type GetBatteriesByBatteryIdPrintlabelResponses = {
    /**
     * WebHook data
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetBatteriesByBatteryIdPrintlabelResponse = GetBatteriesByBatteryIdPrintlabelResponses[keyof GetBatteriesByBatteryIdPrintlabelResponses];

export type GetTasksData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * An array of filter conditions, each of them is a string in the form of `<field><condition><value>` where<br>`<field>` is a valid field name<br>`<condition>` is a comparison operator, one of<br>&nbsp;&nbsp;`=` equal<br>&nbsp;&nbsp;`!=` not equal<br>&nbsp;&nbsp;`~` LIKE<br>&nbsp;&nbsp;`!~` not LIKE<br>&nbsp;&nbsp;`<` less<br>&nbsp;&nbsp;`>` greater<br>&nbsp;&nbsp;`<=` less or equal<br>&nbsp;&nbsp;`>=` greater or equal<br>&nbsp;&nbsp;`§` regular expression<br>`<value>` is the value to search for
         */
        'query[]'?: Array<string>;
        /**
         * A valid field name by which the response should be ordered, use the separator `:` to specify the sort order (`asc` or `desc`, defaults to `asc` when omitted)
         */
        order?: string;
        /**
         * The maximum number of objects to return
         */
        limit?: number;
        /**
         * The number of objects to skip
         */
        offset?: number;
    };
    url: '/tasks';
};

export type GetTasksErrors = {
    /**
     * The operation was not successful (possible errors are invalid field names or conditions in filter parameters provided)
     */
    500: Error500;
};

export type GetTasksError = GetTasksErrors[keyof GetTasksErrors];

export type GetTasksResponses = {
    /**
     * An array of CurrentTaskResponse objects
     */
    200: Array<CurrentTaskResponse>;
};

export type GetTasksResponse = GetTasksResponses[keyof GetTasksResponses];

export type PostTasksByTaskIdCompleteData = {
    body: {
        /**
         * The time of when the task was completed, when omitted, the current time is used
         */
        done_time?: string;
    };
    path: {
        /**
         * A valid task id
         */
        taskId: number;
    };
    query?: never;
    url: '/tasks/{taskId}/complete';
};

export type PostTasksByTaskIdCompleteErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing task)
     */
    400: Error400;
};

export type PostTasksByTaskIdCompleteError = PostTasksByTaskIdCompleteErrors[keyof PostTasksByTaskIdCompleteErrors];

export type PostTasksByTaskIdCompleteResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostTasksByTaskIdCompleteResponse = PostTasksByTaskIdCompleteResponses[keyof PostTasksByTaskIdCompleteResponses];

export type PostTasksByTaskIdUndoData = {
    body?: never;
    path: {
        /**
         * A valid task id
         */
        taskId: number;
    };
    query?: never;
    url: '/tasks/{taskId}/undo';
};

export type PostTasksByTaskIdUndoErrors = {
    /**
     * The operation was not successful (possible errors are: Not existing task)
     */
    400: Error400;
};

export type PostTasksByTaskIdUndoError = PostTasksByTaskIdUndoErrors[keyof PostTasksByTaskIdUndoErrors];

export type PostTasksByTaskIdUndoResponses = {
    /**
     * The operation was successful
     */
    204: void;
};

export type PostTasksByTaskIdUndoResponse = PostTasksByTaskIdUndoResponses[keyof PostTasksByTaskIdUndoResponses];

export type GetCalendarIcalData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/calendar/ical';
};

export type GetCalendarIcalErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type GetCalendarIcalError = GetCalendarIcalErrors[keyof GetCalendarIcalErrors];

export type GetCalendarIcalResponses = {
    /**
     * The iCal file contents
     */
    200: string;
};

export type GetCalendarIcalResponse = GetCalendarIcalResponses[keyof GetCalendarIcalResponses];

export type GetCalendarIcalSharingLinkData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/calendar/ical/sharing-link';
};

export type GetCalendarIcalSharingLinkResponses = {
    /**
     * The (public) sharing link for the calendar in iCal format
     */
    200: {
        url?: string;
    };
};

export type GetCalendarIcalSharingLinkResponse = GetCalendarIcalSharingLinkResponses[keyof GetCalendarIcalSharingLinkResponses];

export type GetPrintShoppinglistThermalData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Shopping list id
         */
        list?: number;
        /**
         * Prints Grocy logo if true
         */
        printHeader?: boolean;
    };
    url: '/print/shoppinglist/thermal';
};

export type GetPrintShoppinglistThermalErrors = {
    /**
     * The operation was not successful
     */
    400: Error400;
};

export type GetPrintShoppinglistThermalError = GetPrintShoppinglistThermalErrors[keyof GetPrintShoppinglistThermalErrors];

export type GetPrintShoppinglistThermalResponses = {
    /**
     * Returns OK if the printing was successful
     */
    200: {
        result?: string;
    };
};

export type GetPrintShoppinglistThermalResponse = GetPrintShoppinglistThermalResponses[keyof GetPrintShoppinglistThermalResponses];

export type ClientOptions = {
    baseUrl: 'https://grocy.it-joost.jvn/api' | (string & {});
};